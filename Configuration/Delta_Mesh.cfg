# # # Klipper Adaptive Meshing # # #

# Heads up! If you have any other BED_MESH_CALIBRATE macros defined elsewhere in your config, you will need to comment out / remove them for this to work. (Klicky/Euclid Probe)
# You will also need to be sure that [exclude_object] is defined in printer.cfg, and your slicer is labeling objects.
# This macro will parse information from objects in your gcode to define a min and max mesh area to probe, creating an adaptive mesh!
# This macro will not increase probe_count values in your [bed_mesh] config. If you want richer meshes, be sure to increase probe_count. We recommend at least 5,5.

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BED_MESH_CALIBRATE
gcode:

    {% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}                                # Gather all object points
    {% set round_probe_count = printer.configfile.settings.bed_mesh.round_probe_count %}                                            # Get probe count from printer.cfg
    {% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}                                           # Pull verbose setting from _KAMP_Settings
    {% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}                                               # Pull mesh margin setting from _KAMP_Settings
    {% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}                                               # Pull fuzz amount setting from _KAMP_Settings
    # {% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}                                             # If probe count is only a single number, convert it to 2. E.g. probe_count:7 = 7,7

    {% set default_delta_origin_x = printer.configfile.settings.bed_mesh.mesh_origin[0] %}
    {% set default_delta_origin_y = printer.configfile.settings.bed_mesh.mesh_origin[1] %}
    {% set default_delta_radius = printer.configfile.settings.bed_mesh.mesh_radius %}

    {% set x_min = all_points | map(attribute=0) | min %}
    {% set y_min = all_points | map(attribute=1) | min %}
    {% set x_max = all_points | map(attribute=0) | max %}
    {% set y_max = all_points | map(attribute=1) | max %}
    {% set x_origin = (x_max + x_min) / 2 %}
    {% set y_origin = (y_max + y_min) / 2 %}

    {% set distance = 0 %}
    {% set ns = namespace(max_distance=0) %}  
    {% for point in all_points %}
        {% set distance = ((point[0]-x_origin) ** 2 + (point[1]-y_origin) ** 2) ** 0.5 %}
        {% set ns.max_distance = [ns.max_distance, distance] | max %}
    {% endfor %}

    {% if ns.max_distance < default_delta_radius %}
        {% set delta_radius = ns.max_distance %}
    {% else %}
        {% set delta_radius = default_delta_radius %}
        {% set x_origin = default_delta_origin_x %}
        {% set y_origin = default_delta_origin_y %}
    {% endif %}

    {% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}                                                          # Set fuzz_range between 0 and fuzz_amount
    # {% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}            # Adapt x_min to margin and fuzz constraints
    # {% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}            # Adapt y_min to margin and fuzz constraints
    # {% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}            # Adapt x_max to margin and fuzz constraints
    # {% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}            # Adapt y_max to margin and fuzz constraints

    # {% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}          # Define probe_count's x point count and round up
    # {% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}          # Define probe_count's y point count and round up

    # {% if (([points_x, points_y]|max) > 6) %}                                                                                       # 
    #     {% set algorithm = "bicubic" %}                                                                                             # 
    #     {% set min_points = 4 %}                                                                                                    # 
    # {% else %}                                                                                                                      # Calculate if algorithm should be bicubic or lagrange
    #     {% set algorithm = "lagrange" %}                                                                                            # 
    #     {% set min_points = 3 %}                                                                                                    # 
    # {% endif %}                                                                                                                     # 

    # {% set points_x = [points_x, min_points]|max %}                                                                                 # Set probe_count's x points to fit the calculated algorithm
    # {% set points_y = [points_y, min_points]|max %}                                                                                 # Set probe_count's y points to fit the calculated algorithm
    # {% set points_x = [points_x, probe_count[0]]|min %}
    # {% set points_y = [points_y, probe_count[1]]|min %}

    {% if printer.configfile.settings.bed_mesh.relative_reference_index is defined %}                                               #
        {% set ref_index = (points_x * points_y / 2) | int %}                                                                       #
    {% else %}                                                                                                                      # Set reference index to be point closest to adapted mesh center point if defined
        {% set ref_index = -1 %}                                                                                                    #
    {% endif %}                                                                                                                     #

    {% if verbose_enable == True %}                                                                                                 # If verbose is enabled, print information about KAMP's calculations

        { action_respond_info( "Algorithm: {}.".format(                                                                              
            (algorithm),                                                                                                            
        )) }

        { action_respond_info("Default probe count: {},{}.".format(                                                                  
            (probe_count[0]),                                                                                                       
            (probe_count[1]),                                                                                                       
        )) }

        { action_respond_info("Adapted probe count: {},{}.".format(                                                                  
            (points_x),                                                                                                             
            (points_y),                                                                                                             
        )) }

        {% if ref_index != -1 %}                                                                                                    
            { action_respond_info( "Reference index adjusted to: {}.".format(ref_index) ) }                                          
        {% else %}                                                                                                                  
            { action_respond_info( "Reference index: None." ) }                                                                      
        {% endif %}                                                                                                                 

        {action_respond_info("Default mesh bounds: {}, {}.".format(                                                                  
            (bed_mesh_min[0],bed_mesh_min[1]),                                                                                      
            (bed_mesh_max[0],bed_mesh_max[1]),                                                                                      
        )) }

        {% if mesh_margin > 0 %}                                                                                                    
            {action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(                                       
                (mesh_margin),                                                                                                      
                (mesh_margin),                                                                                       
            )) }                                                                                                                    
        {% else %}                                                                                                                  
            {action_respond_info("Mesh margin is 0, margin not increased.")}                                                        
        {% endif %}                                                                                                                 

        {% if fuzz_amount > 0 %}                                                                                                    
            {action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(                                     
                (fuzz_amount),                                                                                                      
            )) }                                                                                                                    
        {% else %}                                                                                                                  
            {action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}                                                      
        {% endif %}                                                                                                                 

        { action_respond_info("Adapted mesh bounds: {}, {}.".format(                                                                 
            (adapted_x_min, adapted_y_min),                                                                                         
            (adapted_x_max, adapted_y_max),                                                                                         
        )) }

        {action_respond_info("KAMP adjustments successful. Happy KAMPing!")}

    {% endif %}

    {% if probe_dock_enable == True %}
        {attach_macro}                                                                                                              # Attach/deploy a probe if the probe is stored somewhere outside of the print area
    {% endif %}

    _BED_MESH_CALIBRATE MESH_ORIGIN={x_origin},{y_origin} MESH_RADIUSs={mesh_radius} ALGORITHM={algorithm} ROUND_PROBE_COUNT={round_probe_count} RELATIVE_REFERENCE_INDEX={ref_index}

    {% if probe_dock_enable == True %}
        {detach_macro}                                                                                                              # Detach/stow a probe if the probe is stored somewhere outside of the print area
    {% endif %}                                                                                                                     # End of verbose

    ################################################################

[gcode_macro _KAMP_Get_Delta_Params]
description: HELPER - Gets the origin and radius values for adaptive meshing with delta printers
gcode:

    # Get all defined object points.
    {% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
 
    # Get XY min/max area from object bounds.
    {% set x_min = all_points | map(attribute=0) | min %}
    {% set y_min = all_points | map(attribute=1) | min %}
    {% set x_max = all_points | map(attribute=0) | max %}
    {% set y_max = all_points | map(attribute=1) | max %}

    # Convert bounding box to center point (round mesh origin).
    {% set x_origin = (x_max + x_min) / 2 %}
    {% set y_origin = (y_max + y_min) / 2 %}

    # Get XY origin point and radius from [bed_mesh] configuration.
    {% set default_delta_origin_x = printer.configfile.settings.bed_mesh.mesh_origin[0] %}
    {% set default_delta_origin_y = printer.configfile.settings.bed_mesh.mesh_origin[1] %}
    {% set default_delta_radius = printer.configfile.settings.bed_mesh.mesh_radius %}
    
    # Calculate radius values to object points from mesh_origin and pick the largest one.
    {% set distance = 0 %}
    {% set ns = namespace(max_distance=0) %}  
    {% for point in all_points %}
        {% set distance = ((point[0]-x_origin) ** 2 + (point[1]-y_origin) ** 2) ** 0.5 %}
        {% set ns.max_distance = [ns.max_distance, distance] | max %}
    {% endfor %}

    # If calculated radius is smaller than default mesh_radius, use calculated radius. If not, use default.
    {% if ns.max_distance < default_delta_radius %}
        {% set delta_radius = ns.max_distance %}
    {% else %}
        {% set delta_radius = default_delta_radius %}
        {% set x_origin = default_delta_origin_x %}
        {% set y_origin = default_delta_origin_y %}
    {% endif %}

    # Send calculated values to Adaptive Mesh macro.
    # SET_GCODE_VARIABLE MACRO=Adaptive_Mesh VARIABLE=delta_origin VALUE={[x_origin, y_origin]}
    # SET_GCODE_VARIABLE MACRO=Adaptive_Mesh VARIABLE=delta_radius VALUE={delta_radius}

    { action_respond_info("Origin found at [{!r}], radius calculated is {}".format(
        (x_origin, y_origin),
        delta_radius,
    )) }